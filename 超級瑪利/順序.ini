遊戲具備 僅可增加的map x

遊戲檔案檢查
while << 遊戲主迴圈 

    按鍵(上左右) >> 加速度  loopstage == 1
    加速度(x, y) >> 速度    loopstage == 2
    阻力(x方向) >> 速度     loopstage == 3

    for (速度x拆分成0.01*n)            << 用途:原本 腳色x-速度x 
        loopstage == 4
        碰撞(偵測x) >> improt檔案 >> 回傳碰撞數值 << 邏輯:這一次移動是否碰撞且位於何，會碰撞則停止這次碰撞撞牆則設定碰速度歸零
        碰撞(偵測x) >> 左(物體的) if player_x + math.copysign(0.001, velocity_x) > (object_1_x-player_sizex) return 1
        碰撞(偵測x) >> 右(物體的) if player_x + math.copysign(0.001, velocity_x) < (object_1_x+object_1_sizex) return -1
    

        if 碰撞0
            速度方向*0.01 >> 腳色x
    
    for (速度y拆分成0.01*n) 
        loopstage == 5
        碰撞(偵測y) 
        碰撞(偵測y) >> 上(物體的) if player_y + math.copysign(0.001, velocity_y) > (object_1_y-player_sizey) return -1
        碰撞(偵測y) >> 下(物體的) if player_y + math.copysign(0.001, velocity_y) < (object_1_y+object_1_sizey) return 1

        if 碰撞0 or 1
            速度方向*0.01 >> 腳色y






地圖檔說明 << 先建立物體圖形，以矩形為主 
    命名方式 << 物件 n 的x座標(object_n_x)
                物件 n 的y座標(object_n_y)
                物件 n 的x方向寬度(object_n_sizex)
                物件 n 的y方向寬度(object_n_sizey)
    建立順序 << 建立圖形的座標及XY寬度(以左上角為(0, 0)) > 建立地圖(不動的) > 建立機關 > 建立腳色出場位置 

建立文本 << 紀錄當前遊戲狀態
            場景觸發狀況
            腳色死亡次數
            遊戲進度
地圖繪製工具 << 還沒有明確想法，之後再做





地圖檔具備 >> 地圖(不動) 
              陷阱機關(移動物件EX:香菇、突然出現的方塊)
              腳色出場位置
              過關條件

地圖 >> (塞在 for (x 移動 & y 移動))
    def map_n (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage) :
    物件名稱 >> (觸發的機關於事件中建立)
        def map_1 (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage) :
    object = [ << 以視窗左下角作為(0, 0)建立物件
        [object_1_x, height - object_1_y, object_1_weigh, objet_1_hight],
        [object_2_x, height - object_2_y, object_2_weigh, objet_2_hight],
        [object_3_x, height - object_3_y, object_3_weigh, objet_3_hight],
                                :
                                :
                                :
        [object_n_x, height - object_n_y, object_n_weigh, objet_n_hight]
    ]
    create_time = len(object)
    碰撞判斷模組 >> 
        def collision (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y,object) :
            create_time = len(object)
            if loopstage == 4 :
                for time_c in range(0, create_time,1) : #and (player_x + player_sizex) <= object[time_c][0]
                    time_c_int = round(time_c, 0)
                    if collision_x == 0 :
                        if player_x + math.copysign(0.001, velocity_x) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + player_sizex) <= (object[time_c_int][0] - map_x) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : #  碰撞(偵測x) >> 左(物體的) 
                            collision_x = 1
                        else :
                            collision_x = 0
                        if player_x + math.copysign(0.001, velocity_x) < (object[time_c_int][0] - map_x + object[time_c_int][2]) and player_x > (object[time_c_int][0] - map_x + object[time_c_int][2]) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : # 碰撞(偵測x) >> 右(物體的)
                            collision_x = -1
            if loopstage == 5 :
                for time_c in range(0, create_time,1) :  #and (player_y + player_sizey) <= object[time_c][1] 
                    time_c_int = round(time_c, 0)
                    if collision_y == 0 :
                        if player_y + math.copysign(0.001, velocity_y) > (height - object[time_c_int][1] - player_sizey) and (player_y + player_sizey) < (height - object[time_c_int][1]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 上(物體的)
                            collision_y = -1
                        else :
                            collision_y = 0
                        if player_y + math.copysign(0.001, velocity_y) < (height - object[time_c_int][1] + object[time_c_int][3]) and player_y > (height - object[time_c_int][1] + object[time_c_int][3]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 下(物體的)
                            collision_y = 1
            def_return = [collision_x , collision_y]
            return def_return

        繪製物件 << 位置為(map_x, y) map_x以最左邊為0
        可導入貼圖
    事件 >> 

完成進度 >>
    架構 >>
    完成 >> 
        碰撞模組
    待辦 >> 
        主畫面
        地圖貼圖導入 << 地圖貼圖應位於最上層(腳色及地圖物件可以不用畫，陷阱機關一定要畫(要用pygame.event判定是否觸碰))

        按鍵控制模組
        移動加速度模組
        跳躍模組
        阻力模組
        移動模組

        陷阱機關 >> (像素級檢測碰撞     if pygame.sprite.collide_mask(sprite1, sprite2): ) (
    import pygame
    from pygame.locals import *

    pygame.init()

    # 加载图像
    image1 = pygame.image.load('image1.png').convert_alpha()
    image2 = pygame.image.load('image2.png').convert_alpha()

    # 创建精灵对象
    sprite1 = pygame.sprite.Sprite()
    sprite1.image = image1
    sprite1.rect = image1.get_rect()

    sprite2 = pygame.sprite.Sprite()
    sprite2.image = image2
    sprite2.rect = image2.get_rect()

    # 设置精灵的位置
    sprite1.rect.topleft = (100, 100)
    sprite2.rect.topleft = (150, 150)

    # 执行像素级碰撞检测
    if pygame.sprite.collide_mask(sprite1, sprite2):
        print("发生碰撞")
    else:
        print("未发生碰撞")
    )
            NPC(碰到會怎樣的那種)
            出現的掉落物(反正就是會讓你死掉的那種)

        關卡設置
        結束條件




使用pygame套件檢測碰撞 >>
    架構 >>  矩形檢測碰撞
        碰撞判斷模組 >>{
def collision (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y,object) :
    create_time = len(object)


    if loopstage == 4 :
        player_x = player_x + math.copysign(0.001, velocity_x)
        for time_c in range(0, create_time,1) : #and (player_x + player_sizex) <= object[time_c][0]
            time_c_int = round(time_c, 0)
            player_collision_box = pygame.Rect(player_x, player_y, player_sizex, player_sizey)
            object_collision_box = pygame.Rect(object[time_c_int][0] - map_x, (height - object[time_c_int][1]), object[time_c_int][2], object[time_c_int][3])
            if collision_x == 0 :
                if  player_collision_box.colliderect(object_collision_box) : #  碰撞(偵測x) >> 左(物體的) 
                    collision_x = -1
                if player_collision_box.colliderect(object_collision_box) : # 碰撞(偵測x) >> 右(物體的)
                    collision_x = 1
    
    if loopstage == 5 :
        player_y = player_y + math.copysign(0.001, velocity_y)
        for time_c in range(0, create_time,1) :   
            time_c_int = round(time_c, 0)
            player_collision_box = pygame.Rect(player_x, player_y, player_sizex, player_sizey)
            object_collision_box = pygame.Rect(object[time_c_int][0] - map_x, (height - object[time_c_int][1]), object[time_c_int][2], object[time_c_int][3])
            if collision_y == 0 :
                if player_collision_box.colliderect(object_collision_box) and (player_y) < (height - object[time_c_int][1]) : # 碰撞(偵測y) >> 上(物體的)
                    collision_y = -1
                elif player_collision_box.colliderect(object_collision_box) : # 碰撞(偵測y) >> 下(物體的)
                        collision_y = 1
    def_return = [collision_x , collision_y]
    return def_return
}

#碰撞判斷模組 << 舊的
def collision (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y,object) :
    create_time = len(object)
    if loopstage == 4 :
        for time_c in range(0, create_time,1) : 
            time_c_int = round(time_c, 0)
            if collision_x == 0 :
                
                if player_x + math.copysign(0.001, velocity_x) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + player_sizex) <= (object[time_c_int][0] - map_x) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : #  碰撞(偵測x) >> 左(物體的) 
                    collision_x = 1
                    
                else :
                    collision_x = 0
                if player_x + math.copysign(0.001, velocity_x) < (object[time_c_int][0] - map_x + object[time_c_int][2]) and player_x > (object[time_c_int][0] - map_x + object[time_c_int][2]) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : # 碰撞(偵測x) >> 右(物體的)
                    collision_x = -1
            
    if loopstage == 5 :
        for time_c in range(0, create_time,1) :   
            time_c_int = round(time_c, 0)
            if collision_y == 0 :
                if player_y + math.copysign(0.001, velocity_y) > (height - object[time_c_int][1] - player_sizey) and (player_y + player_sizey) < (height - object[time_c_int][1]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 上(物體的)
                    collision_y = -1
                else :
                    collision_y = 0
                if player_y + math.copysign(0.001, velocity_y) < (height - object[time_c_int][1] + object[time_c_int][3]) and player_y > (height - object[time_c_int][1] + object[time_c_int][3]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 下(物體的)
                    collision_y = 1
    def_return = [collision_x , collision_y]
    return def_return






    git 指令 >> 
    cd Cat-Mario/
    git add .
    git commit -m "記錄檔名稱(日期或更新內容都行)"
    git push
    git config --global user.email "你的Gmail"
    git config --global user.name "暱稱"