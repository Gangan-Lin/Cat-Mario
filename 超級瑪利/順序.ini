導入工具
初始化
設定各項數值
物理模擬
    模組 >>
        按鍵偵測模組
        移動(按鍵操控)模組
        阻力模組
        移動模組
        碰撞判斷模組
        碰撞方塊繪製模組
腳色精靈創建
    提片更換模組
邊界設置
地圖 >>
    map_1
遊戲Clock
while << 遊戲主迴圈 
    設定按鍵 << 迴圈第1階段
    移動(加速度) & 二段跳躍設定 << 迴圈第2階段
    移動阻力 << 迴圈第3階段
    x 方向碰撞 + 移動 << 迴圈第4階段
    y 方向碰撞 + 移動 << 迴圈第5階段
    清空畫面 << 迴圈第7階段
    畫出玩家碰撞方塊 << 迴圈第8階段
    畫出地圖碰撞方塊 << 迴圈第9階段
    
    更新畫面
    控制遊戲迴圈速度

地圖檔說明 << 先建立物體圖形，以矩形為主    建立順序 : 建立圖形的座標及XY寬度(以左上角為(0, 0)) > 建立地圖(不動的) > 建立機關 > 建立腳色出場位置
    地圖檔具備 >> 地圖(不動) 
              陷阱機關(移動物件EX:香菇、突然出現的方塊)
              腳色出場位置
              過關條件
    命名方式 << 物件 n 的x座標(object_n_x)
                物件 n 的y座標(object_n_y)
                物件 n 的x方向寬度(object_n_weigh)
                物件 n 的y方向寬度(object_n_hight)
        地圖 >> (塞在 for (x 移動 & y 移動))
            物件名稱 >> 
                def map_1 (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y) :
                    object_map = [
                        [object_1_x, object_1_y, object_1_weigh, objet_1_hight],
                        [object_2_x, object_2_y, object_2_weigh, objet_2_hight],
                        [object_3_x, object_3_y, object_3_weigh, objet_3_hight],
                                        :
                                        :
                                        :
                        [object_n_x, object_n_y, object_n_weigh, objet_n_hight]
                    ]
                    def_return = collision_model(player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y, object_map)
                    collisionbox_draw_model(player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y, object_map, screen, blue)
                    return def_return
        導入貼圖 >> 
            未完成

        機關 >>
            未完成

建立文本 << 紀錄當前遊戲狀態 (不一定要)
            場景觸發狀況
            腳色死亡次數
            遊戲進度
地圖繪製工具 << 還沒有明確想法，之後再做


完成進度 >>
    架構 >>
    完成 >> 
        碰撞模組
        按鍵控制模組
        移動加速度模組
        跳躍模組
        阻力模組
        移動模組
    待辦 >> 
        主畫面
        地圖貼圖導入 << 地圖貼圖應位於最上層(腳色及地圖物件可以不用畫，陷阱機關一定要畫(要用pygame.event判定是否觸碰))
        陷阱機關 >> (像素級碰撞檢測     if pygame.sprite.collide_mask(sprite1, sprite2): ) << 地圖也能用這種檢測方式，這樣的話只要導入貼圖就可以直接使用，但難點在於求出碰撞點，不然無法判斷腳色是在上還是在下，能夠做到不重合，但無法判斷是否踩地。
        {
    import pygame
    from pygame.locals import *

    pygame.init()

    # 加載圖片
    image1 = pygame.image.load('image1.png').convert_alpha()
    image2 = pygame.image.load('image2.png').convert_alpha()

    # 創建精靈
    sprite1 = pygame.sprite.Sprite()
    sprite1.image = image1
    sprite1.rect = image1.get_rect()

    sprite2 = pygame.sprite.Sprite()
    sprite2.image = image2
    sprite2.rect = image2.get_rect()

    # 設置精靈
    sprite1.rect.topleft = (100, 100)
    sprite2.rect.topleft = (150, 150)

    # 像素碰撞檢測
    if 
        print("發生碰撞")

        print("未發生碰撞")
    }
            
            NPC(碰到會怎樣的那種)
            出現的掉落物(反正就是會讓你死掉的那種)

        關卡設置
        結束條件




使用pygame套件檢測碰撞 >>
    架構 >>  矩形檢測碰撞
        碰撞判斷模組 >>{
def collision_model (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y, object_map) :
    create_time = len(object_map)

    if loopstage == 4 :
        player_x = player_x + math.copysign(0.001, velocity_x)
        for time_c in range(0, create_time,1) : 
            time_c_int = round(time_c, 0)
            player_collision_box = pygame.Rect(player_x, player_y, player_sizex, player_sizey)
            object_collision_box = pygame.Rect(object_map[time_c_int][0] - map_x, (height - object_map[time_c_int][1]), object_map[time_c_int][2], object_map[time_c_int][3])
            if collision_x == 0 :
                if  player_collision_box.colliderect(object_collision_box) : # 碰撞(偵測x) >> 左右不影響
                    collision_x = 1
    
    if loopstage == 5 :
        player_y = player_y + math.copysign(0.001, velocity_y)
        for time_c in range(0, create_time,1) :   
            time_c_int = round(time_c, 0)
            player_collision_box = pygame.Rect(player_x, player_y, player_sizex, player_sizey)
            object_collision_box = pygame.Rect(object_map[time_c_int][0] - map_x, (height - object_map[time_c_int][1]), object_map[time_c_int][2], object_map[time_c_int][3])
            if collision_y == 0 :
                if player_collision_box.colliderect(object_collision_box) and (player_y) < (height - object_map[time_c_int][1]) : # 碰撞(偵測y) >> 上(物體的)
                    collision_y = -1
                elif player_collision_box.colliderect(object_collision_box) : # 碰撞(偵測y) >> 下(物體的)
                        collision_y = 1

    def_return = [collision_x , collision_y]
    return def_return
}

#碰撞判斷模組 << 舊的
def collision (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y,object) :
    create_time = len(object)
    if loopstage == 4 :
        for time_c in range(0, create_time,1) : 
            time_c_int = round(time_c, 0)
            if collision_x == 0 :
                
                if player_x + math.copysign(0.001, velocity_x) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + player_sizex) <= (object[time_c_int][0] - map_x) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : #  碰撞(偵測x) >> 左(物體的) 
                    collision_x = 1
                    
                else :
                    collision_x = 0
                if player_x + math.copysign(0.001, velocity_x) < (object[time_c_int][0] - map_x + object[time_c_int][2]) and player_x > (object[time_c_int][0] - map_x + object[time_c_int][2]) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : # 碰撞(偵測x) >> 右(物體的)
                    collision_x = -1
            
    if loopstage == 5 :
        for time_c in range(0, create_time,1) :   
            time_c_int = round(time_c, 0)
            if collision_y == 0 :
                if player_y + math.copysign(0.001, velocity_y) > (height - object[time_c_int][1] - player_sizey) and (player_y + player_sizey) < (height - object[time_c_int][1]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 上(物體的)
                    collision_y = -1
                else :
                    collision_y = 0
                if player_y + math.copysign(0.001, velocity_y) < (height - object[time_c_int][1] + object[time_c_int][3]) and player_y > (height - object[time_c_int][1] + object[time_c_int][3]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 下(物體的)
                    collision_y = 1
    def_return = [collision_x , collision_y]
    return def_return



#陷阱機關模組



    
    
    
    git 指令 >> 
    cd ../Cat-Mario
    git add .
    git commit -m "記錄檔名稱(日期或更新內容都行)"
    git push
    git config --global user.email "你的Gmail"
    git config --global user.name "暱稱"


            
            player_collision_box = pygame.Rect(player_x_here, self.player_y, self.player_sizex, self.player_sizey)
            # 加載圖片(.convert_alpha() << 背景透明化用的)
            image_player = pygame.image.load(self.player_image).convert_alpha()
            # 獲取圖像矩形對象
            rect_player = image_player.get_rect(topleft=(self.player_x, self.player_y))
            # 建立像素掩碼
            player_mask = pygame.mask.from_surface(image_player)
            # 創建精靈
            sprite_player = pygame.sprite.Sprite()
    
            for time_c in range(0, create_time_map,1) : 
                if self.collision_trap == 0 :
                    time_c_int = round(time_c, 0)