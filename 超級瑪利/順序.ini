遊戲具備 僅可增加的map x

遊戲檔案檢查
while << 遊戲主迴圈 

    按鍵(上左右) >> 加速度  loopstage == 1
    加速度(x, y) >> 速度    loopstage == 2
    阻力(x方向) >> 速度     loopstage == 3

    for (速度x拆分成0.01*n)            << 用途:原本 腳色x-速度x 
        loopstage == 4
        碰撞(偵測x) >> improt檔案 >> 回傳碰撞數值 << 邏輯:這一次移動是否碰撞且位於何，會碰撞則停止這次碰撞撞牆則設定碰速度歸零
        碰撞(偵測x) >> 左(物體的) if player_x + math.copysign(0.001, velocity_x) > (object_1_x-player_sizex) return 1
        碰撞(偵測x) >> 右(物體的) if player_x + math.copysign(0.001, velocity_x) < (object_1_x+object_1_sizex) return -1
    

        if 碰撞0
            速度方向*0.01 >> 腳色x
    
    for (速度y拆分成0.01*n) 
        loopstage == 5
        碰撞(偵測y) 
        碰撞(偵測y) >> 上(物體的) if player_y + math.copysign(0.001, velocity_y) > (object_1_y-player_sizey) return -1
        碰撞(偵測y) >> 下(物體的) if player_y + math.copysign(0.001, velocity_y) < (object_1_y+object_1_sizey) return 1

        if 碰撞0 or 1
            速度方向*0.01 >> 腳色y






地圖檔說明 << 先建立物體圖形，以矩形為主 
    命名方式 << 物件 n 的x座標(object_n_x)
                物件 n 的y座標(object_n_y)
                物件 n 的x方向寬度(object_n_sizex)
                物件 n 的y方向寬度(object_n_sizey)
    建立順序 << 建立圖形的座標及XY寬度(以左上角為(0, 0)) > 建立地圖(不動的) > 建立機關 > 建立腳色出場位置 

建立文本 << 紀錄當前遊戲狀態
            場景觸發狀況
            腳色死亡次數
            遊戲進度
地圖繪製工具 << 還沒有明確想法，之後再做





地圖檔具備 >> 地圖(不動) 
              陷阱機關(移動物件EX:香菇、突然出現的方塊)
              腳色出場位置
              過關條件

地圖 >> (塞在 for (x 移動 & y 移動))
    def map_n (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage) :
    物件名稱 >> (觸發的機關於事件中建立)
        def map_1 (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage) :
    object = [ << 以視窗左下角作為(0, 0)建立物件
        [object_1_x, height - object_1_y, object_1_weigh, objet_1_hight],
        [object_2_x, height - object_2_y, object_2_weigh, objet_2_hight],
        [object_3_x, height - object_3_y, object_3_weigh, objet_3_hight],
                                :
                                :
                                :
        [object_n_x, height - object_n_y, object_n_weigh, objet_n_hight]
    ]
    create_time = len(object)
    碰撞判斷模組 >> 
        def collision (player_x, velocity_x, player_y, velocity_y, height, player_sizey, map_x, loopstage, collision_x, collision_y,object) :
            create_time = len(object)
            if loopstage == 4 :
                for time_c in range(0, create_time,1) : #and (player_x + player_sizex) <= object[time_c][0]
                    time_c_int = round(time_c, 0)
                    if collision_x == 0 :
                        if player_x + math.copysign(0.001, velocity_x) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + player_sizex) <= (object[time_c_int][0] - map_x) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : #  碰撞(偵測x) >> 左(物體的) 
                            collision_x = 1
                        else :
                            collision_x = 0
                        if player_x + math.copysign(0.001, velocity_x) < (object[time_c_int][0] - map_x + object[time_c_int][2]) and player_x > (object[time_c_int][0] - map_x + object[time_c_int][2]) and (player_y + math.copysign(0.001, velocity_y)) > (height - object[time_c_int][1] - player_sizey) and ( player_y + math.copysign(0.001, velocity_y)) < (height - object[time_c_int][1] + object[time_c_int][3]) : # 碰撞(偵測x) >> 右(物體的)
                            collision_x = -1
            if loopstage == 5 :
                for time_c in range(0, create_time,1) :  #and (player_y + player_sizey) <= object[time_c][1] 
                    time_c_int = round(time_c, 0)
                    if collision_y == 0 :
                        if player_y + math.copysign(0.001, velocity_y) > (height - object[time_c_int][1] - player_sizey) and (player_y + player_sizey) < (height - object[time_c_int][1]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 上(物體的)
                            collision_y = -1
                        else :
                            collision_y = 0
                        if player_y + math.copysign(0.001, velocity_y) < (height - object[time_c_int][1] + object[time_c_int][3]) and player_y > (height - object[time_c_int][1] + object[time_c_int][3]) and (player_x + math.copysign(0.001, velocity_x)) > (object[time_c_int][0] - map_x - player_sizex) and (player_x + math.copysign(0.001, velocity_x)) < (object[time_c_int][0] - map_x + object[time_c_int][2]): # 碰撞(偵測y) >> 下(物體的)
                            collision_y = 1
            def_return = [collision_x , collision_y]
            return def_return

        繪製物件 << 位置為(map_x, y) map_x以最左邊為0
        可導入貼圖
    事件 >> 
git 指令 >> 
    cd Cat-Mario/
    git add .
    git commit -m "記錄檔名稱(日期或更新內容都行)"
    git push
    git config --global user.email "你的Gmail"
    git config --global user.name "暱稱"
完成進度 >>
    架構 >>
    完成 >> 
        碰撞模組
    待辦 >> 
        主畫面
        地圖貼圖導入 << 地圖貼圖應位於最上層(腳色及地圖物件可以不用畫，陷阱機關一定要畫(要用pygame.event判定是否觸碰))

        按鍵控制模組
        移動加速度模組
        跳躍模組
        阻力模組
        移動模組

        陷阱機關
            NPC(碰到會怎樣的那種)
            出現的掉落物(反正就是會讓你死掉的那種)

        關卡設置
        結束條件





在Pygame中，pygame.Rect类提供的碰撞检测方法（如colliderect）是基于矩形的，因此不能直接用于检测三角形的碰撞。然而，你可以使用其他方法来检测三角形的碰撞。

一种方法是使用点和多边形的碰撞检测。你可以将三角形表示为三个点的集合，然后使用点和多边形的碰撞检测算法。下面是一个简单的示例：
import pygame
import sys

pygame.init()

# 设置窗口大小
width, height = 400, 300
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("碰撞事件示例")

# 定义三角形的三个顶点
triangle_points = [(150, 50), (100, 150), (200, 150)]

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    # 渲染
    screen.fill((255, 255, 255))
    pygame.draw.polygon(screen, (0, 0, 255), triangle_points)

    # 检测鼠标点击事件
    if pygame.mouse.get_pressed()[0]:  # 左键点击
        mouse_x, mouse_y = pygame.mouse.get_pos()

        # 使用点和多边形的碰撞检测
        if pygame.Rect(*triangle_points[0], 1, 1).collidepoint(mouse_x, mouse_y) or \
           pygame.Rect(*triangle_points[1], 1, 1).collidepoint(mouse_x, mouse_y) or \
           pygame.Rect(*triangle_points[2], 1, 1).collidepoint(mouse_x, mouse_y):
            print("碰撞发生！")

    pygame.display.flip()
在这个例子中，我们使用pygame.draw.polygon绘制三角形，
并通过collidepoint检测鼠标点击事件时鼠标的位置是否在三角形的任意一个顶点上。
你可以根据实际情况适配代码，以适应你的游戏对象和碰撞检测需求。如果需要更复杂的碰撞检测，可能需要使用专门的数学库或算法。